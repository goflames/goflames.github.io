<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LeetCode27 移除元素</title>
      <link href="/2024/01/10/LeetCode27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"/>
      <url>/2024/01/10/LeetCode27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<p><strong>题目地址：</strong><br><a href="https://leetcode.cn/problems/remove-element/description/">LeetCode 27 移除元素</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 额外空间并 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地 </a>修改输入数组</strong>。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素</p><h2 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h2><p>首先，注意到题目中最重要的一条要求是：<strong>不能使用额外的数组空间。</strong></p><p>也就是说，我们必须采取原地修改该数组的方法进行解题，而数组在内存空间中是一片连续的区域，它的元素是不可被删除的，只能被覆盖。</p><p>最容易想到的办法是采用循环嵌套，内外两层进行遍历，最终获得数组的新长度，此时，代码实现方式为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums[i] == val)&#123;</span><br><span class="line">        <span class="comment">//当找到目标值val时，循环遍历剩下的所有元素，并往前移一位</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; size; j++)&#123;</span><br><span class="line">            nums[j - <span class="number">1</span>] = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">        i--;<span class="comment">//让i回到被移除的val的前一位，继续下一次移动，否则可能漏掉元素</span></span><br><span class="line">        length--;<span class="comment">//由于“删除”了一个val，因此新数组的size - 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> length;</span><br></pre></td></tr></table></figure><p>这种解法虽然可以AC，但是代码可读性与算法时间复杂度（O(n²)）都不理想，下面我们使用双指针的解法，优化时间复杂度。</p><h2 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h2><p>首先，我们定义两个指针，finder和getter。</p><p>顾名思义，finder指针用于寻找目标元素val，而getter指针则是用于获取覆盖元素的元素，完整代码及注释如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">finder</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">getter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(finder = <span class="number">0</span>; finder &lt; length; finder++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums[finder] != val)&#123;</span><br><span class="line">        <span class="comment">//如果当前元素不是需要被移除的元素，那么它应当被getter所在的位置获取到</span></span><br><span class="line">        nums[getter] = nums[finder];</span><br><span class="line">        getter++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果当前元素是需要被移除的元素，getter不会进行获取操作，并且会在原地停留，也就是不和finder一起做++操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> getter;<span class="comment">//数组的新长度正是getter最后停留的下标</span></span><br></pre></td></tr></table></figure><p>使用双指针法解题，空间复杂度和时间复杂度均优于循环嵌套法，题解的关键在于能否理解两个指针分别的作用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 239 滑动窗口最大值 单调队列方法解题思路</title>
      <link href="/2023/12/12/Leetcode-239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E6%96%B9%E6%B3%95%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF/"/>
      <url>/2023/12/12/Leetcode-239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E6%96%B9%E6%B3%95%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-239-滑动窗口最大值-单调队列方法解题思路"><a href="#Leetcode-239-滑动窗口最大值-单调队列方法解题思路" class="headerlink" title="Leetcode 239 滑动窗口最大值 单调队列方法解题思路"></a>Leetcode 239 滑动窗口最大值 单调队列方法解题思路</h1><p><a href="https://leetcode.cn/problems/sliding-window-maximum/">Leetcode 239 滑动窗口最大值</a></p><h2 id="题目-思路分析"><a href="#题目-思路分析" class="headerlink" title="题目&amp;思路分析"></a>题目&amp;思路分析</h2><p><strong>题目</strong> 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p>返回 滑动窗口中的最大值 。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">3</span>,-<span class="number">1</span>,-<span class="number">3</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>], k = <span class="number">3</span></span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure><p><strong>分析</strong> 这是一道经典的单调队列题目，本文亦采用了这种方法来进行解题。</p><h2 id="定义单调队列"><a href="#定义单调队列" class="headerlink" title="定义单调队列"></a>定义单调队列</h2><p>通过对于题设和输入例子的分析，不难想到一种暴力的解法，即用两个for循环嵌套进行遍历，记录每个窗口中的最大值，最终得到结果数组。</p><p>这种暴力解法的思路虽然好理解，但是时间复杂度较高（O（n * k）），显然使用单调队列是更优的做法。</p><p>单调队列，故名思义，即维持队列中的元素是单调的，或递增，或递减，根据自己的需求进行控制。这里我们使用Java中的双端队列（Deque）来实现，使用的实现类是最常用的LinkedList。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span>&#123;</span><br><span class="line">  <span class="comment">//双端队列 两边都可以进出</span></span><br><span class="line">  Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在单调队列中添加元素"><a href="#在单调队列中添加元素" class="headerlink" title="在单调队列中添加元素"></a>在单调队列中添加元素</h3><p>那么本题中我们到底需要单调递增的队列还是单调递减的队列呢？答案显然是后者，因为我们所求的结果是一个窗口里的最大值，需要被维护的元素是更大的元素。通俗来讲，假如在一个窗口长度为3的情况下，我们把这三个元素都加入队列的时候，应当保留谁呢？当然是保留更大的元素。用Leetcode给出的用例来举个例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">3</span>,-<span class="number">1</span>,-<span class="number">3</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>] k = <span class="number">3</span></span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure><p>第一个长度为k的滑动窗口情况是：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">3</span>,-<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>依次加入队列：队列为空时，1 会首先被加入队列，第二个被加入的元素会是3。但此时我们不难想到，1还有必要留在队列中吗？答案显然是否定的，因为在本个窗口中，已经出现了比它更大的元素，所以它已经不可能是本个窗口里需要被收集的值了。第三个需要被加入的元素是 -1 ，那么或许会有一个想法？是不是在已经有 3 存在的情况下，-1 也不需要被加入队列了呢？那肯定是不行的。因为我们只能看见当前滑动窗口里面的值，虽然 -1 在当前窗口里不是最大值，但我们无法保证它在后面的滑动窗口中也不是最大值，假设题目变更为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">3</span>,-<span class="number">1</span>,-<span class="number">2</span>,-<span class="number">3</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure><p>那么当滑动窗口滑到：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[-<span class="number">1</span>,-<span class="number">2</span>,-<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>-1 不也就是需要被收集的值了吗？</p><p>所以，经过这样一番分析后，我们可以整理出在设计这个单调队列时，添加元素的逻辑。</p><ul><li>在添加元素时，当队列为空，直接添加；当队列不为空，检查已有元素和当前元素的大小关系，移除前面所有比当前元素更小的值，再添加元素。</li></ul><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">    <span class="comment">//添加元素 检查前面是否有比自己小的元素</span></span><br><span class="line">    <span class="comment">//注意队列非空条件的添加，不要操作空队列了</span></span><br><span class="line">    <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.getLast() &lt; val)&#123;</span><br><span class="line">        deque.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">        deque.add(val);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="在单调队列中弹出元素"><a href="#在单调队列中弹出元素" class="headerlink" title="在单调队列中弹出元素"></a>在单调队列中弹出元素</h3><p>完成了添加元素的逻辑，我们接着思考弹出元素的逻辑，而这一步是相对简单的。</p><p>依然是以题设给出的用例为例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">3</span>,-<span class="number">1</span>,-<span class="number">3</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>] k = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>在完成第一个窗口元素添加后，队列中的情况是这样的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">3</span>,-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>当窗口开始滑动，此时 -3需要被加入队列，意味着前一个滑动窗口的第一个值需要被移除了。但很显然，第一个元素 1 在我们将 3 加入队列的时候就已经被remove了，那要怎么poll它呢？</p><p>先不急，我们再往后滑动一位，也就是说我们要把元素5加入队列了，那么此时应该先把上一个滑动窗口的第一个元素（3）先移除，再进行5的添加逻辑。</p><p>而 3 是什么？ 3 是此时队列的出口元素，deque.peek() &#x3D;&#x3D; 3。那么是不是可以这么认为，当传入的值val 与 deque.peek() 相等时，我们才进行poll操作？</p><p>我们来验证一下这个逻辑：</p><ul><li>当-3 需要被加入队列时，此时传入给poll方法的值是1，而1与出口处的3不相等，不执行任何操作。</li><li>当5需要被加入队列时，传入给poll方法的值为3，与出口处的元素相等了，应该被弹出了。</li></ul><p>所以根据以上逻辑，可以写出如下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">poll</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="comment">//弹出元素 </span></span><br><span class="line">        <span class="comment">//检查出口的值是不是等于最大值，等于再弹出 同样注意不要操作空队列</span></span><br><span class="line">        <span class="keyword">if</span>(!deque.isEmpty() &amp;&amp; deque.peek() == val)&#123;</span><br><span class="line">            deque.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="得到单调队列出口处的元素（每个窗口里的最大值）"><a href="#得到单调队列出口处的元素（每个窗口里的最大值）" class="headerlink" title="得到单调队列出口处的元素（每个窗口里的最大值）"></a>得到单调队列出口处的元素（每个窗口里的最大值）</h3><p>完成了添加和移除元素的逻辑，就剩下最后最简单的peek方法需要被完善了。</p><p>其实我们已经可以发现，经过了上面两个逻辑的设计，队列出口处的元素会一直是滑动窗口里的最大值。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int peek()&#123;</span><br><span class="line">        //拿到最大值</span><br><span class="line">        //双端队列出口处的值就是最大值</span><br><span class="line">        return deque.peek();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="主函数设计"><a href="#主函数设计" class="headerlink" title="主函数设计"></a>主函数设计</h2><p>完成单调队列的定义后，本题的核心逻辑其实就完成了，主函数的设计就是水到渠成的事情。</p><p>完整代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] maxSlidingWindow(int[] nums, int k) &#123;</span><br><span class="line">    //如果nums里面只有1个元素，最大值就是它自己</span><br><span class="line">        if(nums.length == 1)&#123;</span><br><span class="line">            return nums;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //拿到数组的长度</span><br><span class="line">        int length = nums.length;</span><br><span class="line">        </span><br><span class="line">        //new 一个存放结果的数组</span><br><span class="line">        int[] result = new int[length - k + 1];</span><br><span class="line"></span><br><span class="line">        MyQueue queue = new MyQueue();</span><br><span class="line">        </span><br><span class="line">        //定义数组的下标</span><br><span class="line">        int index = 0;</span><br><span class="line">        </span><br><span class="line">        //先把前k个放进单调队列</span><br><span class="line">        for(int i = 0; i &lt; k; i++)&#123;</span><br><span class="line">            queue.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //此时应该得到result的第一个值</span><br><span class="line">        result[index] = queue.peek();</span><br><span class="line">        //这个index 应该是先添加了数组元素 再进行++操作</span><br><span class="line">        index++;</span><br><span class="line"></span><br><span class="line">        //依次收集 i的边界条件应当取到最后一个数组元素</span><br><span class="line">        for(int i = k; i &lt; length ; i++)&#123;</span><br><span class="line">            //先把第一个元素poll </span><br><span class="line">            //i - k 的含义 就是上一个滑动窗口的第一个元素</span><br><span class="line">            queue.poll(nums[i - k]);</span><br><span class="line">            //添加新的</span><br><span class="line">            queue.add(nums[i]);</span><br><span class="line">            //得到出口处的最大值</span><br><span class="line">            result[index] = queue.peek();</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里有几个注意点再说一下：</p><ol><li><p>为什么结果数组的长度是 length - k + 1?</p><p>因为在遍历nums时，i &#x3D;  k -1 时收集到了第一个最大值</p><p>遍历到最后一个元素，即 i &#x3D; length - 1 时，收集到了最后一个最大值</p><p>所以中间有多少个元素？就应该是（length - 1）-  (k - 1) + 1 个元素，化简一下得到 length - k + 1</p></li><li><p>result 数组的下标 index++的时机，应当在添加了一个最大值以后再++，注意不要写反了。简写result[index++] 也可以。</p></li><li><p>在第二个for循环模拟窗口开始滑动的过程中，注意poll和add的顺序，不要写反，并且每次滑动都要取一次peek。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这是一道经典的单调队列题目，只要想通了如何设计这个单调队列，那么主函数的设计反而是相对更简单的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础：DQL查询</title>
      <link href="/2023/11/19/MySQL%E5%9F%BA%E7%A1%80%EF%BC%9ADQL%E6%9F%A5%E8%AF%A2/"/>
      <url>/2023/11/19/MySQL%E5%9F%BA%E7%A1%80%EF%BC%9ADQL%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL基础：DQL查询"><a href="#MySQL基础：DQL查询" class="headerlink" title="MySQL基础：DQL查询"></a>MySQL基础：DQL查询</h1><h2 id="1-条件查询"><a href="#1-条件查询" class="headerlink" title="1.条件查询"></a>1.条件查询</h2><h3 id="1-1-条件查询语法"><a href="#1-1-条件查询语法" class="headerlink" title="1.1 条件查询语法"></a>1.1 条件查询语法</h3><p>select 字段列表  from table where <strong>条件列表</strong>；</p><h3 id="1-2-举例用法"><a href="#1-2-举例用法" class="headerlink" title="1.2 举例用法"></a>1.2 举例用法</h3><p>以下加粗部分为条件列表：</p><ul><li>select * from table where <strong>age &gt; 18;</strong></li><li>select * from table where <strong>age &lt; 18;</strong></li><li>select * from table where <strong>age &lt;&#x3D; 18;</strong></li><li>select * from table where id_num <strong>is null;</strong></li><li>select * from table where id_num <strong>is not null;</strong></li><li>select * from table where <strong>age !&#x3D; 18;</strong></li><li>select * from table where <strong>age &gt;&#x3D; 15 &amp;&amp; age &lt;&#x3D; 20</strong>;（包含边界值，实际过程中 &amp;&amp; 比较少用，常用and关键字）</li><li>select * from table where **age between 15 and 20;**（也包含边界值，使用between时，前后不能写反）</li><li>select * from table where <strong>gender &#x3D; ‘女’  and age &gt; 18</strong>;</li><li>select * from table where  <strong>age &lt; 18 or age &gt; 40;</strong></li><li>select * from table where <strong>age in (15,20,30)</strong>;（条件三选一满足即可）</li></ul><p><strong>模糊匹配</strong>：like </p><p>单个字符：_</p><p>任意字符：%</p><ul><li>select * from table where name like ‘__’;（两个下划线，name有两个字符）</li><li>select * from table where id_code like ‘%0’;（%代表任意字符，表示id_code最后一位为0的数据，但是%不一定有多少个字符）</li></ul><h2 id="2-聚合函数"><a href="#2-聚合函数" class="headerlink" title="2. 聚合函数"></a>2. 聚合函数</h2><p>共五个，作用于表中的某一列数据，也就是某一个字段</p><h3 id="2-1-语法"><a href="#2-1-语法" class="headerlink" title="2.1 语法"></a>2.1 语法</h3><p>select 聚合函数名（字段列表） from table ;</p><h3 id="2-2-5个聚合函数及其作用"><a href="#2-2-5个聚合函数及其作用" class="headerlink" title="2.2 5个聚合函数及其作用"></a>2.2 5个聚合函数及其作用</h3><ul><li>count —-&gt; 统计数量</li><li>max —–&gt; 取最大值</li><li>min ——&gt; 取最小值</li><li>avg ——&gt; 取平均值</li><li>sum ——-&gt; 求和</li></ul><h3 id="2-3-举例用法"><a href="#2-3-举例用法" class="headerlink" title="2.3 举例用法"></a>2.3 举例用法</h3><p>统计整张表的数据量：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select <span class="title function_">count</span><span class="params">(*)</span> from table;</span><br></pre></td></tr></table></figure><p>取表中年龄最大的数据：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select <span class="title function_">max</span><span class="params">(age)</span> from table;</span><br></pre></td></tr></table></figure><p>同理，取最小：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select <span class="title function_">min</span><span class="params">(age)</span> from table;</span><br></pre></td></tr></table></figure><p>取全表年龄的平均值：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select <span class="title function_">avg</span><span class="params">(age)</span> from table;</span><br></pre></td></tr></table></figure><p>取全表年龄之和：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select <span class="title function_">sum</span><span class="params">(age)</span> from table;</span><br></pre></td></tr></table></figure><p>统计所有女性员工的年龄之和：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select <span class="title function_">sum</span><span class="params">(age)</span> from table <span class="type">where</span> <span class="variable">gender</span> <span class="operator">=</span> <span class="string">&#x27;Female&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="2-4-注意"><a href="#2-4-注意" class="headerlink" title="2.4 注意"></a>2.4 注意</h3><p>所有的null值不参与聚合函数的运算，比如说某一条数据的age值为null，那么以age为字段列表取统计数量时，将不会将这一条数据统计进count出来的最终数量</p><h2 id="3-分组查询"><a href="#3-分组查询" class="headerlink" title="3.分组查询"></a>3.分组查询</h2><p>GROUP BY </p><h3 id="3-1-语法"><a href="#3-1-语法" class="headerlink" title="3.1 语法"></a>3.1 语法</h3><p>select 字段列表 from 表名 【where  条件】 GROUP BY 分组的字段名 【HAVING 分组后过滤条件】</p><p>括号里的内容可有可无</p><h3 id="3-2-WHERE-和-HAVING-的区别"><a href="#3-2-WHERE-和-HAVING-的区别" class="headerlink" title="3.2 WHERE 和 HAVING 的区别"></a>3.2 WHERE 和 HAVING 的区别</h3><ul><li>执行时间： where 在执行分组之前，having在分组之后</li><li>判断条件：where 中不能使用聚合函数，但是having可以</li></ul><h3 id="3-3-举例用法"><a href="#3-3-举例用法" class="headerlink" title="3.3 举例用法"></a>3.3 举例用法</h3><p>根据地址分组，统计每一个地址的人数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select addr,count(*) from table GROUP BY addr;</span><br></pre></td></tr></table></figure><p>根据地区进行分组，统计每一个地区的平均年龄：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select addr,avg() from table group by addr;</span><br></pre></td></tr></table></figure><p>查询年龄小于35的员工，并且根据地区分组，获取人数大于3的地区；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select addr,count(*) addr_count from table where age &lt; <span class="number">35</span> group by addr having addr_count &gt; <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>其中 addr_count 是count（*）的别名</p><p>执行顺序：</p><p>where —&gt; 聚合函数 —-&gt; having </p><h3 id="3-4-注意"><a href="#3-4-注意" class="headerlink" title="3.4 注意"></a>3.4 注意</h3><p>进行分组查询时，一般展示聚合函数和分组的字段，查询其他字段是无意义的错误数据</p><h2 id="4-排序查询"><a href="#4-排序查询" class="headerlink" title="4.排序查询"></a>4.排序查询</h2><p>ORDER BY</p><h3 id="4-1-语法"><a href="#4-1-语法" class="headerlink" title="4.1 语法"></a>4.1 语法</h3><p>select 字段 from table order by 字段1 排序方式1，字段2  排序方式2；</p><p>支持多个字段排序</p><h3 id="4-2-举例用法"><a href="#4-2-举例用法" class="headerlink" title="4.2 举例用法"></a>4.2 举例用法</h3><p>查询所有数据，并且根据年龄进行升序排序：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select * from table order by age asc;</span><br></pre></td></tr></table></figure><p>其中asc可以不写，因为默认值是升序排序</p><p>查询所有数据，根据年龄进行排序，如果年龄相同，根据数据创建时间降序排序</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select * from table order by age asc, create_date desc;</span><br></pre></td></tr></table></figure><h2 id="5-分页查询"><a href="#5-分页查询" class="headerlink" title="5. 分页查询"></a>5. 分页查询</h2><p>LIMIT</p><p>这是一个方言，不同的数据库可能不一样，MySQL中使用的关键字是LIMIT</p><h3 id="5-1-语法"><a href="#5-1-语法" class="headerlink" title="5.1 语法"></a>5.1 语法</h3><p>select 字段列表 from 表名 <strong>LIMIT</strong> 起始索引，查询记录数；</p><h3 id="5-2-注意"><a href="#5-2-注意" class="headerlink" title="5.2 注意"></a>5.2 注意</h3><ul><li>起始索引从0开始，计算公式： <em><em>start_index &#x3D; （页码 - 1）</em> 每一页记录数；</em>*</li><li>不同的数据库对于分页查询的关键字不同，MySQL中是LIMIT，其他数据库可能不一样</li><li>如果查询的是首页数据，起始索引可以省略，直接写每一页返回的记录数量；</li></ul><h3 id="5-3-举例用法"><a href="#5-3-举例用法" class="headerlink" title="5.3 举例用法"></a>5.3 举例用法</h3><p>查询第一页的数据，每一页返回20条数据</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select * from table limit <span class="number">0</span>, <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">select * from table limit  <span class="number">20</span>; <span class="comment">// 查询首页，起始索引可以省略</span></span><br></pre></td></tr></table></figure><p>查询第二页的数据，每一页返回50条数据；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select * from table limit <span class="number">1</span>, <span class="number">50</span>;</span><br></pre></td></tr></table></figure><h2 id="6-综合案例"><a href="#6-综合案例" class="headerlink" title="6.综合案例"></a>6.综合案例</h2><h3 id="6-1-案例"><a href="#6-1-案例" class="headerlink" title="6.1 案例"></a>6.1 案例</h3><p>查询年龄为18，19，20 岁的数据：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select * from table where age <span class="title function_">in</span> <span class="params">(<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>)</span>;</span><br></pre></td></tr></table></figure><p>查询性别为女，且年龄在20-40之间，姓名为2个字的数据：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select * from table <span class="type">where</span> <span class="variable">gender</span> <span class="operator">=</span> <span class="string">&#x27;female&#x27;</span> and (age between <span class="number">20</span> and <span class="number">40</span>) and name like <span class="string">&#x27;__&#x27;</span>;</span><br></pre></td></tr></table></figure><p>分别统计年龄小于35岁的男女人数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select <span class="title function_">count</span><span class="params">(*)</span>,gender from table where age &lt; <span class="number">35</span> group by gender;</span><br></pre></td></tr></table></figure><p>分组之前进行条件过滤；</p><p>查询性别为女，且年龄在20-40之间的前10个员工数据，按照年龄升序，如年龄相同，按照创建时间降序排序：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select * from table <span class="type">where</span> <span class="variable">gender</span> <span class="operator">=</span> <span class="string">&#x27;female&#x27;</span> and age &gt;=<span class="number">20</span> and age &lt;= <span class="number">40</span> order by age asc,create_time desc limit <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h3 id="6-2-DQL的执行顺序"><a href="#6-2-DQL的执行顺序" class="headerlink" title="6.2 DQL的执行顺序"></a>6.2 DQL的执行顺序</h3><p>编写顺序：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select </span><br><span class="line">    字段列表</span><br><span class="line">from</span><br><span class="line">    表名列表</span><br><span class="line">where</span><br><span class="line">    条件列表</span><br><span class="line">group by</span><br><span class="line">    分组字段列表</span><br><span class="line">having</span><br><span class="line">    分组后过滤条件列表</span><br><span class="line">order by</span><br><span class="line">    排序列表</span><br><span class="line">limit</span><br><span class="line">    分页参数</span><br></pre></td></tr></table></figure><p>执行顺序：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">from</span><br><span class="line">where</span><br><span class="line">group by</span><br><span class="line">having</span><br><span class="line">select</span><br><span class="line">order by</span><br><span class="line">limit</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM基础知识整理</title>
      <link href="/2023/11/11/JVM%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
      <url>/2023/11/11/JVM%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM基础知识理解"><a href="#JVM基础知识理解" class="headerlink" title="JVM基础知识理解"></a>JVM基础知识理解</h1><p>全称是 Java Virtual Machine，即我们常说的Java虚拟机，本质上也是一种软件，不同的操作系统需要适配不同的JVM安装包，最终功能都是能够执行字节码，<strong>这就是JVM能够跨平台的本质。</strong></p><h2 id="1、字节码与JVM"><a href="#1、字节码与JVM" class="headerlink" title="1、字节码与JVM"></a>1、字节码与JVM</h2><p>Java代码通过编译阶段转换成字节码格式的文件（hello.java –&gt; hello.class），字节码再去到JVM里面运行，看似是字节码体现出了跨平台的特性，本质上还是不同的操作系统上有自己适配的JVM。</p><h2 id="2、JVM整体结构"><a href="#2、JVM整体结构" class="headerlink" title="2、JVM整体结构"></a>2、JVM整体结构</h2><p>这个结构可以通过一个Java代码文件从程序员编写到被编译成计算机能够执行的机器指令的完整过程来辅助进行理解。</p><ul><li>程序员编写Java代码，得到一个java文件（hello.java）</li><li>编译器将其编译为字节码文件 hello.java –&gt; hello.class（这个文件是在磁盘中）</li><li>hello.class 进入类加载子系统，这一步就是把磁盘中的.class文件加载到内存中去</li><li>类加载子系统将字节码指令放到JVM内存区域中的方法区</li><li>JVM中的执行引擎（解释器）去执行内存中的字节码指令，JVM中的垃圾回收器也在执行引擎里。解释器实际上就是把字节码指令翻译成为机器指令，与此同时，字节码指令中有一些热点指令（高频出现），为了提高效率，执行引擎中的JIT编译器会去编译处理这些热点指令，并将其缓存，避免解释器去重复解释热点指令，影响效率。</li><li>执行指令的过程中，会产生一些Java对象，而这些对象就存在堆内存中。</li><li>执行字节码指令的过程本质上就是在执行Java的方法，执行的时候会在Java栈里创建一个栈帧，方法里的一些局部变量等就存在这个栈帧里面。</li><li>线程也可能会执行一下native 方法（JVM里面用C语言或C++编写的方法）。</li><li>执行指令过程中可能会不停地切换线程，程序计数器会记录下一条指令执行的地址，方便进行切换。</li></ul><h3 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h3><p>它负责把字节码文件（.class）加载到方法区里的内存空间中。</p><h4 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h4><p>主要有三个步骤：</p><ol><li>加载</li><li>链接</li></ol><ul><li>验证：主要验证字节码文件是否正确，确保不会威胁到JVM的安全，比如文件格式等</li><li>准备：在堆里面去给一些statci的变量或者属性分配内存，并且赋值（注意这里<strong>是赋0值</strong>，也就是默认值，比如定义一个 static int a &#x3D; 1, 那么在这个阶段是先给a 赋值为 0；又比如定义一个static boolean flag &#x3D; true，在这个阶段先赋值为false）</li><li>解析：这一步是把符号引用解析为直接引用。比如，字节码指令中引用了一些java对象，在java代码中是通过这个对象的全限名去找的，等于只是通过名字（符号）去找对象，这一步就是要把符号引用变成直接引用，也就是直接<strong>去找这个对象在JVM里面的地址。</strong></li></ul><ol start="3"><li>初始化：给类里面static的属性或者变量赋值（执行Java里面写的代码了）</li></ol><h4 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h4><p>既可以按照引导类加载器和自定义类加载器分成两大类，也可以按照默认和真正的自定义类加载器分成四种类型。</p><p>这里主要讲JDK默认提供的三种加载器：</p><ol><li>BootStrapClassLoader：引导类加载器，加载的目录是jre&#x2F;lib下面的目录</li><li>ExtClassLoader：jre&#x2F;lib&#x2F;ext</li><li>AppClassLoader：当前项目指定的classpath下，targer&#x2F;classes里面的类</li></ol><h4 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h4><ol><li>避免类的重复加载</li><li>防止核心API被篡改</li></ol><p>当ClassLoader想要去加载一个类的时候，会去调用一个叫做loadClass的方法，那么在这个方法里面，会有一段代码先检查当前这个类加载器的parent属性是否为空，如果不为空，就让parent去加载这个类。</p><p>举个例子：</p><p>当AppClassLoader调用loadClass方法加载某个类，进入方法发现parent属性不为空，那么就进入ExtClassLoader执行loadClass，此时ExtClassLoader的parent属性虽然为空，但不代表它就会直接自行加载这个类，因为 c &#x3D; findBootStrapOrNull，虽然它没有parent属性，但是事实上有这个找双亲继续加载的功能。</p><p>如果最上层的BootStrap加载不到，它就返给Ext，如果ext也加载不到，就返给APP。</p><h4 id="Tomcat为什么要自定义类加载器（WebappClassLoader）"><a href="#Tomcat为什么要自定义类加载器（WebappClassLoader）" class="headerlink" title="Tomcat为什么要自定义类加载器（WebappClassLoader）"></a>Tomcat为什么要自定义类加载器（WebappClassLoader）</h4><p><strong>实现类加载的隔离</strong></p><h3 id="JVM运行时数据区"><a href="#JVM运行时数据区" class="headerlink" title="JVM运行时数据区"></a>JVM运行时数据区</h3><p>分为五块区域：</p><ol><li><p>方法区：经过类加载子系统处理过后的类信息就存在这里，除此以外这里还有常量池和一些方法信息。所有线程共享。</p></li><li><p>堆内存：程序执行过程中会产生很多对象，这些对象都存在这里。细分有新生代和老年代，默认比例是1:2，新生代中又有eden区、from区和to区。这里也是所有线程共享。</p></li><li><p>Java方法栈：里面是无数个栈帧，每一个栈帧里面又有局部变量表、动态链接、操作数栈、方法返回地址等。这里是线程私有的，也就是每一个线程有自己一块Java方法栈区域。</p></li><li><p>Native方法栈： JVM里面的一些用C或者C++写的本地方法。也是线程私有。</p></li><li><p>程序计数器：最简单的一块区域。它用来记录当前线程的下一条指令的执行地址。JVM规范中唯一一个没有OutOfMemoryError的一个区域。（前面提及的解释器，就是通过它来获取下一条字节码指令的地址）</p></li></ol><h4 id="Java方法栈"><a href="#Java方法栈" class="headerlink" title="Java方法栈"></a>Java方法栈</h4><p> 首先，虚拟机栈是线程私有的，创建一个线程，这个线程就有一个自己的虚拟机栈。</p><ol><li>在线程执行的过程中，实际上就是在调用一个又一个的Java方法，每一个方法被调用的时候，就会在这个线程的虚拟机栈里生成一个栈帧。如果这个方法又调用了另一个方法，那么虚拟机栈里面就会继续生成栈帧。</li><li>虚拟机栈里面是不需要进行垃圾回收操作的，因为当一个方法执行完毕后，栈帧会自动出栈。与此同时，虚拟机栈会出现StackOverflow，最常见的一个情况就是递归方法没有写好终止条件，一直在不停地创建新的栈帧，最后导致栈内存溢出。</li><li>除了StackOverflow，也可能会出现OutOfMemoryError。两者的区别在于，栈内存溢出是某个线程的虚拟机栈内存不够，而OOM是因为线程数量过多，导致在线程创建时没有足够的内存空间给它创建虚拟机栈。</li><li>可以通过调整参数来设置虚拟机栈的大小，-Xss</li></ol><h5 id="栈帧（Java栈和本地方法栈都有栈帧）"><a href="#栈帧（Java栈和本地方法栈都有栈帧）" class="headerlink" title="栈帧（Java栈和本地方法栈都有栈帧）"></a>栈帧（Java栈和本地方法栈都有栈帧）</h5><p>栈帧里面会有局部变量表、操作数栈、方法返回地址、动态链接。</p><ul><li>局部变量表里面又有很多Slot，记录每个局部变量在表中的位置。局部变量表本身就是记录每个变量的值是什么。</li><li>操作数栈就是在执行字节码指令时，辅助进行计算的一个东西</li></ul><h4 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h4><p>JVM规定所有对象和数组都存在堆里，调用方法时会产生的栈帧（如上上述）里面实际上存的是对象在堆里面的地址，而不是真正的对象，所以当栈帧消失的时候，对象并不会消失。对象只会被垃圾回收器回收。</p><p>同样可以通过设置参数调整大小：</p><p>-Xms：（memory start） 堆内存的初始大小</p><p>-Xmx：（memory max）堆内存的最大内存大小</p><p>但通常会把这两个参数设置为一样的，因为这样在垃圾回收之后不需要再去修改堆内存的大小，节约资源提高效率。</p><p>但默认情况下，初始大小是物理内存的1&#x2F;64，最大内存是物理内存的1&#x2F;4。</p><h5 id="新生代-老年代"><a href="#新生代-老年代" class="headerlink" title="新生代&amp;老年代"></a>新生代&amp;老年代</h5><p>堆内存大小确认之后，里面划分为新生代区和老年代区，且默认比例是1:2，老年代所占空间更大。这个比例一般不调整，但如果需要调整的话可以通过 - XX: NewRatio 这个参数来调整。</p><p>新生代中又划分了Eden区、S0区和S1区（from区和to区），默认比例为8:1:1。（同样可以通过-XX：SurvivorRatio 这个参数来调整）。</p><p>Minor GC（YOUNG GC）以及对象如何进入老年代的过程梳理：</p><p>当一个对象被新创建时，它会进入Eden区，随着对象越来越多，Eden区的内存空间不足，就会触发Minor GC，此时Eden区中已经死亡的对象将会被回收，尚且存活的对象就会进入S0（From）区，并且会带上标记（记录经历了几次Minor GC），这是第一次Minor GC的过程。第二次GC开始会同时对新生代里所有区域进行检查并GC，还存活的对象就会被放入另一个S区，并且每经历一次Minor GC，年龄+1。（From 和 To 总是在交替工作，总有一个被清空）</p><p>直到一个对象的年龄到了阈值（默认为15），就会在最后一次Minor GC的时候被转入老年代。</p><p>还有一些对象直接进入老年代的情况，比如一个存活对象可以存放在Eden区中，但是S区放不下，它在第一次Minor GC就会被转入老年代，而更大一些的、连整个Eden区都放不下的对象，从创建开始就会被放在老年区。</p><h5 id="Minor-GC-Major-GC-Full-GC区别"><a href="#Minor-GC-Major-GC-Full-GC区别" class="headerlink" title="Minor GC&amp;Major GC&amp;Full GC区别"></a>Minor GC&amp;Major GC&amp;Full GC区别</h5><p>Minor：对新生代进行回收</p><p>Major：对老年代进行回收</p><p>Full：整个堆回收</p><p>现有的垃圾回收器普遍有针对新生代单独回收的机制，但是只在整堆回收的时候处理老年代。而CMS回收器，是唯一一个有对老年代进行单独回收处理机制的垃圾回收器。</p><h5 id="垃圾回收的过程"><a href="#垃圾回收的过程" class="headerlink" title="垃圾回收的过程"></a>垃圾回收的过程</h5><ol><li><p>标记阶段：引用计数法或者可达性分析法。</p><p>引用计数法：单独用一个计数器记录这个对象被引用的次数，当计数为0，说明它是垃圾对象。</p><p>缺点：需要单独开辟一个空间给它计数；无法解决循环引用的问题，有些对象永远无法被回收。所以这个方法不常用。</p><p><strong>可达性分析法：</strong></p><p>根据GC Roots去一层一层地找被引用的对象，最终没有被找到的对象说明没有被任何一个GC Root 引用，就是垃圾对象。</p><p>GC Roots是一组引用，常用的比如Java栈和本地方法栈的栈帧中的局部变量、方法区中某个类里面的静态属性引用的对象、或者常量属性的引用对象。</p></li><li><p>回收算法：</p><ul><li>标记清除法</li><li>标记整理法</li><li>复制法 ： 通常用在新生代里。因为这里垃圾对象多，可达对象少，复制成本低。而且复制后引用地址发生了改变，栈帧里面也需要修改。</li></ul></li><li><p>三种算法的对比：</p><table><thead><tr><th></th><th>标记清除</th><th>标记整理</th><th>复制算法</th></tr></thead><tbody><tr><td>速度</td><td>适中</td><td>最慢</td><td>最快</td></tr><tr><td>空间开销</td><td>少，原地回收</td><td>少，</td><td>多，每次只能用一半的空间</td></tr><tr><td>是否涉及地址修改</td><td>否，原地回收</td><td>是，整理的时候换了位置</td><td>是，整个被复制到另一块空间</td></tr></tbody></table></li></ol><h5 id="常见的垃圾回收器"><a href="#常见的垃圾回收器" class="headerlink" title="常见的垃圾回收器"></a>常见的垃圾回收器</h5><ul><li>CMS垃圾回收器：</li></ul><p>针对老年代，采用标记清除算法，特点是低暂停。</p><p>工作步骤：</p><ol><li>初始标记 Stop the world，它只找到GC Root 直接引用的那个可达对象，就结束这个标记阶段，所以这一步暂停的时间很短。</li><li>并发标记：这个阶段是垃圾回收线程和用户的线程可以同时工作，所以对于用户来说体验优化了，但缺点就是吞吐量变低。这也是最费时间的一个过程。</li><li>重新标记：由于上一个阶段，垃圾回收和用户线程是并发进行的，所以有可能在并发标记的过程中产生了新的垃圾对象，或者新的可达对象。所以这一步进行STW，修正这种误差。</li><li>并发清理：不会暂停用户线程，垃圾回收线程和用户同时工作。</li><li>并发重置：重置标记。</li></ol><p>但存在一些问题：</p><p><strong>问题1:</strong> 并发标记和并发清理阶段，垃圾回收线程和用户线程在同时工作，所以也可能在此时会有新的对象要进入老年代，但是内存空间不足，此时就会导致“concurrent mode failure”，所以此时会用Serial Old来做一次垃圾收集，造成全局的STW。</p><p><strong>问题2:</strong>  而且在并发清理阶段可能会产生新的垃圾，这些垃圾就无法在本次GC中处理了，只能留到下一次。</p><p><strong>问题3:</strong>  由于是基于标记清除法的垃圾回收器，所以还需要通过指定参数的方式，在完成垃圾回收后进行对象的整理，否则会产生大量内存碎片。</p><ul><li>G1 垃圾回收器：</li></ul><p>把整个堆分成2048个region，每一个region既可以是eden区，也可以是S区，也可以是old区，逻辑上与前面的分法无异，只是从物理空间上来讲可以是不连续的，eden区不一定非要挨着s区。</p><p>多了一个humongous区用于存储大对象（超过region大小的50%）；</p><p>工作步骤：</p><ol><li>Stop the world 进行初始标记</li><li>并发标记</li><li>最终标记 同样进行了一次 STW</li><li>筛选回收 这里也是STW 但注意，这里并不是全部回收，而是根据设定的、能够接受的STW时间（默认200ms），所以本质上是在控制能够接受的暂停时间。优先回收垃圾对象比较多的region，把存活对象复制到相邻的region里面去。</li></ol><p>G1 有一个特殊的<strong>Mixed GC：</strong></p><p>当老年代占用空间到达了一定百分比（可以通过-XX: InitiatingHeadOccupancyPercent来指定），那么就会触发Mixed GC，会回收所有的新生代区域，以及部分老年代区域（因为G1的筛选回收规定了时间，所以不一定会全部回收），还有大对象区（Humongous）；</p>]]></content>
      
      
      <categories>
          
          <category> 技术相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用hugo搭建个人静态博客（Github托管）</title>
      <link href="/2023/11/11/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%EF%BC%88Github%E6%89%98%E7%AE%A1%EF%BC%89/"/>
      <url>/2023/11/11/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%EF%BC%88Github%E6%89%98%E7%AE%A1%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="如何使用hugo搭建个人静态博客（Github托管）"><a href="#如何使用hugo搭建个人静态博客（Github托管）" class="headerlink" title="如何使用hugo搭建个人静态博客（Github托管）"></a>如何使用hugo搭建个人静态博客（Github托管）</h1><h2 id="操作环境"><a href="#操作环境" class="headerlink" title="操作环境"></a>操作环境</h2><p>操作系统 ： MacOS 11.3.1 （M1）</p><p>工具包： VScode、Git </p><h2 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h2><ol><li>拥有一个Github账号</li><li>Mac用户建议提前安装brew，并使用<code>brew install hugo</code> 命令安装hugo；Windows用户请前往<a href="https://gohugo.io/installation/">Hugo官方网站</a>选取适合你系统版本的安装包进行安装。</li><li>安装Git并掌握Git的入门级使用方法</li></ol><h2 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h2><p>整个搭建过程主要包括下载Hugo、创建站点、托管站点、个性化设置等各方面，下面将进行分步说明：</p><h3 id="下载Hugo"><a href="#下载Hugo" class="headerlink" title="下载Hugo"></a>下载Hugo</h3><ul><li><p>Mac用户建议提前安装brew，打开terminal，输入命令：</p><p><code>brew install hugo</code></p><p>等待安装完成即可；</p><p>安装完成后，输入命令：</p><p><code>hugo version</code></p><p>如果出现hugo版本信息，则说明已经安装成功，可以进行下一步。</p></li><li><p>Windows用户请前往<a href="https://gohugo.io/installation/">Hugo官方网站</a>选取适合你系统版本的安装包进行安装，更多信息可以在<a href="https://github.com/gohugoio/hugo#choose-how-to-install">Hugo的Github仓库</a>获取，官方亦提供了通过Github 直接clone的方式进行下载，此处不再赘述。</p></li></ul><h3 id="创建站点"><a href="#创建站点" class="headerlink" title="创建站点"></a>创建站点</h3><p>成功下载完毕后，我们需要创建一个新的站点，打开Terminal，输入命令：</p><p><code>hugo new site myblog</code></p><p>此处myblog为新站点存储源文件的所在地，你可以任意取一个你喜欢的名字。</p><p>之后，使用命令：</p><p><code>cd  /users/appleusername/myblog</code></p><p>进入myblog文件夹，（注意，将appleusername替换为你自己的用户名）再使用：<code>ls -l</code>命令，即可看见hugo自动生成的目录结构。</p><p>其中，几个重要的目录作一些解释：</p><ul><li>content 目录 存放将来发布在网站上的markdown文章</li><li>static 目录 存放静态资源，如网站logo，icon等，还有其他图片资源等</li><li>config.toml 博客的配置文件</li></ul><p>此时，我们已经成功创建了一个新的site。接下来，我们尝试添加一篇markdown文章。</p><p>使用命令：</p><p><code>hugo new post/first.md</code></p><p>该命令将会在前文提及的content目录下，创建post子目录并自动生成一篇markdown格式的文章。此时，我们使用VScode打开myblog文件夹，在content目录下找到post&#x2F;first.md文件，即可进行博客内容的写作。</p><p>至此，我们已经完成了hugo博客的创建和第一篇博客的撰写。</p><p>但在尝试运行该博客之前，我们最好先去下载一个喜欢的theme。这是因为hugo默认生成的站点没有任何皮肤模版，此时直接使用<code>hugo server</code>命令本地运行并打开localhost:1313的话，只能看到一个“Page Not Found”。</p><p>所以，我们先前往<a href="https://themes.gohugo.io/">Hugo官网</a>，寻找一个自己喜欢的theme。通常情况下，每一个theme都有一个Demo或者exampleSite可供效果预览，作者亦提供了相应的说明文档。因此我们只需挑选一个自己喜欢的theme，再回到Terminal：</p><p><code>cd myblog</code></p><p>这里随意举例，假使我需要下载<a href="https://themes.gohugo.io/themes/hugo-blog-awesome/">这个hugo blog awesome</a>，进入该主题的页面，下拉即可找到作者给出的下载方法，在myblog目录下使用命令：</p><p><code>git clone https://github.com/hugo-sid/hugo-blog-awesome.git themes/hugo-blog-awesome</code></p><p>即可将该theme下载到本地themes目录下。</p><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>下载好的theme会有默认的baseUrl，通常是localhost:1313，如果要进行下一步远程托管，务必在配置文件中将baseUrl修改为自己的仓库地址，否则即使代码push成功，也无法访问页面。</p><p>下载完毕后，我们回到根目录myblog，使用命令：</p><p><code>hugo</code></p><p>进行编译，编译后的文件会自动存储在public文件夹下。</p><p>接着，我们尝试在本地运行一下，在myblog目录下使用命令：</p><p><code>hugo server --theme=你下载好的theme的名称 --buildDrafts</code></p><p>如果看见提示：</p><p>Web Server is available at <a href="http://localhost:1313/">http://localhost:1313/</a> (bind address 127.0.0.1)</p><p>Press Ctrl+C to stop</p><p>说明本地运行成功，打开浏览器，访问localhost:1313，即可预览页面效果，同时我们刚刚写好的first.md也会出现在页面上。</p><p>按下 Ctrl+C 结束本地运行。</p><h2 id="托管站点"><a href="#托管站点" class="headerlink" title="托管站点"></a>托管站点</h2><p>当我们在本地尝试运行该博客成功后，想要通过公网访问有多种办法，这里主要详讲如何使用Github进行托管。</p><p>首先，我们需要在自己的Github账户中，创建一个新的repository，仓库名命名为“githubusername.github.io”，请将githubusername替换为你自己的username。</p><p>第二步，回到本地myblog目录，cd进入public文件夹，使用命令：</p><p><code>git init</code></p><p>初始化一下本地仓库</p><p>在这一步骤中，我们随时可以使用<code>git status</code>命令查看仓库中的情况。</p><p><code>git add .</code></p><p>将所有文件提交到暂存区</p><p><code>git commit -m &quot;first commit&quot;</code></p><p>将暂存区的文件commit到本地仓库</p><p>接下来，我们需要将本地仓库与远程Github仓库进行连接，方便后续push文件。</p><h4 id="此处划重点"><a href="#此处划重点" class="headerlink" title="此处划重点"></a>此处划重点</h4><p>在目前很多的教程经验贴或者视频教程中，会使用：</p><p><code>git remote add origin 仓库地址</code></p><p>以本站为例，如果直接使用：</p><p><code>git remote add origin https://FlamesOnly//flamesonly.github.io.git</code></p><p>后续将会提示输入用户名和密码进行权限验证，但值得注意的是，Github在2021年8月已经<strong>停止用username + password来对git操作进行身份验证</strong>，取而代之的是使用令牌进行验证。</p><p>因此，我们最好使用personal token来进行身份验证。操作如下：</p><ol><li>登录个人Github账户</li><li>找到settings，拉到最下方，找到Developer settings</li><li>找到第3个菜单—Personal access tokens</li><li>选择Generate new token</li></ol><p>生成一个token，并注意妥善保存，因为页面一旦刷新后，你将无法再看见该token。</p><p>接着，我们回到myblog目录，<code>cd public</code></p><p>使用命令：</p><p><code>git remote add origin https://&lt;刚刚生成的token&gt;@github.com//&lt;username&gt;/&lt;repository&gt;.git</code></p><p>将username和repository替换为你自己的用户名及仓库地址。</p><p>再使用命令：</p><p><code>git remote -v</code></p><p>如果可以看见</p><p>https:&#x2F;&#x2F;&lt;刚刚生成的token&gt;@github.com&#x2F;&#x2F;<username>&#x2F;<repository>.git（fetch）</p><p>https:&#x2F;&#x2F;&lt;刚刚生成的token&gt;@github.com&#x2F;&#x2F;<username>&#x2F;<repository>.git（push）</p><p>则已经完成了这一步骤</p><p>成功连接远程仓库后，我们使用如下命令进行代码和文件的push，<strong>注意push之前配置文件中是否已经修改了baseUrl为自己的仓库地址，否则push成功也无法访问到页面。</strong></p><p>这里仍然需要在public目录下进行，因为本地仓库在这里：</p><p><code>git push -u origin master</code></p><p>如果提示fatal，无法访问你的仓库，是因为众所周知的网络原因，多次反复尝试push即可；如果提示别的错误，请重新检查远程仓库地址是否指定正确，以及本地Git是否配置正确（是否已经设置username和email）。</p><p>至此，我们就成功地将本地的hugo博客托管到了github上。</p><p>打开浏览器，输入<repository>的地址，即可通过公网访问你的博客了。</p><p>以本站为例，输入”flamesonly.github.io“，你将访问到本站的首页。</p><h3 id="个性化设置"><a href="#个性化设置" class="headerlink" title="个性化设置"></a>个性化设置</h3><p>虽然现成的主题已经能够让我们拥有一个美观的博客页面，但我们仍然希望其中的一些个性化设置可以由自己指定，比如博客的名称，我们不想使用默认的“My Hugo site”，则需要在配置文件中进行修改。</p><p>对于初学者来说，最推荐的方法是将现有主题的config文件直接copy到myblog的根目录，替代默认生成的config.toml文件，并在其中进行个性化的修改。</p><p>不同的主题可能会使用不同格式的配置文件，包括但不限于yaml、toml等，通常title属性就是该博客的名称，footer则是页面下方的版权字体等，我们皆可以根据自己的需要进行修改。</p><p>至于其他进一步的个性化设置，个人认为自行探索是更有乐趣的。</p><p>如果还不懂如何修改配置文件，可以先学习一些HTML基础知识以及善用搜索引擎了解该类格式下配置文件各种属性的作用，即可进行一些简单的修改。</p><p>至此，我们就成功地搭建好了一个可以通过公网访问的个人网站。</p>]]></content>
      
      
      <categories>
          
          <category> 技术相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找 两种区间的思路及三道例题</title>
      <link href="/2023/11/11/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E4%B8%A4%E7%A7%8D%E5%8C%BA%E9%97%B4%E7%9A%84%E6%80%9D%E8%B7%AF%E5%8F%8A%E4%B8%89%E9%81%93%E4%BE%8B%E9%A2%98/"/>
      <url>/2023/11/11/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E4%B8%A4%E7%A7%8D%E5%8C%BA%E9%97%B4%E7%9A%84%E6%80%9D%E8%B7%AF%E5%8F%8A%E4%B8%89%E9%81%93%E4%BE%8B%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="二分查找-两种区间的思路及三道例题"><a href="#二分查找-两种区间的思路及三道例题" class="headerlink" title="二分查找 两种区间的思路及三道例题"></a>二分查找 两种区间的思路及三道例题</h1><p>二分查找法，顾名思义，即每次查找过程结束后，如果未能找到目标值，就将整个区间一分为二，根据目标值与区间中点值之间的大小关系重新确定左右边界。（类似于直接砍掉一半确定不存在目标值的区间）</p><p>因此，二分查找有一个重要的前提，那就是需要被查找的数组是有序的（通常来说是非递减顺序）。</p><p>下面，以<a href="https://leetcode.cn/problems/binary-search/">Leetcode704 二分查找</a>为典型例题，分析两种不同取值区间的思路。</p><h2 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a>704. 二分查找</h2><p><a href="https://leetcode.cn/problems/binary-search/">Leetcode704 二分查找</a></p><p><strong>题目</strong> 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><p><strong>思路分析</strong> 首先，题设给出的数组是一个升序数组，说明数组中的元素从小到大排列且没有重复元素，这是非常典型和适合使用二分查找的前提条件。</p><h3 id="查找区间"><a href="#查找区间" class="headerlink" title="查找区间"></a>查找区间</h3><p>二分查找法最重要的就是确定每一次“砍掉一半”以后，新的区间应该如何确定的问题。</p><p>一般来说，常用的区间就是左闭右闭（ [ left, right ] ），和左闭右开（ [ left, right ））两种取值区间。在不同的题目下，可能使用其中一种区间取值会是更优解，两种解法无优劣之分，下面就这道题目给出两种区间的解题和代码思路。</p><h3 id="左闭右闭（-left-right-）"><a href="#左闭右闭（-left-right-）" class="headerlink" title="左闭右闭（ [ left, right ] ）"></a>左闭右闭（ [ left, right ] ）</h3><p>首先给出左闭右闭区间时代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">// 说明数组中没有元素 或者数组本身为null 肯定不会有目标值存在</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span> || nums == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      </span><br><span class="line"><span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">          </span><br><span class="line">  <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>; </span><br><span class="line">          </span><br><span class="line">  <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">    <span class="comment">//说明区间中点值小于目标值，目标肯定在右边一半的区间</span></span><br><span class="line">    left = mid + <span class="number">1</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">    <span class="comment">//区间中点大于目标值，目标肯定在左边一半的区间</span></span><br><span class="line">    right = mid - <span class="number">1</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//区间中点刚好等于目标值</span></span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">            </span><br><span class="line">  &#125;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">//说明当循环结束，还是没有找到target 返回-1</span></span><br><span class="line">          <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上，是我们对区间进行左闭右闭定义时采取的循环条件和区间取值办法，下面来进行详细说明。</p><ol><li>进入循环的条件为什么是left &lt;&#x3D; right ？</li></ol><p>​如上所述，我们将区间定义为[left, right]，只要这是一个合法区间，我们就应该进入区间进行查找。由于区间左闭右闭，所以left &#x3D;&#x3D; right 仍然是有意义的，应当进入循环。</p><ol start="2"><li>left &#x3D; mid + 1 和 right &#x3D; mid - 1是如何得出？</li></ol><p>​这个问题结合 if 条件句中的判断条件来看，nums[mid] 无论小于还是大于target，都说明了它一定不是我们需要查找的目标值，那么在一个闭合区间内，不需要再放一个已知不可能是答案的值，所以无论移动left还是移动right，都可以直接跳过mid。</p><p>掌握这两个关键问题，就掌握了二分查找法的核心。</p><h3 id="左闭右开（-left-right-））"><a href="#左闭右开（-left-right-））" class="headerlink" title="左闭右开（ [ left, right ））"></a>左闭右开（ [ left, right ））</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(nums.length == <span class="number">0</span> || nums == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//注意，当区间取值为左闭右开时，right就不能再从nums.length - 1开始了</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">          left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">          <span class="comment">//注意看区别</span></span><br><span class="line">          right = mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种区间取值办法中，我们可以注意到，进入循环的条件发生了变化，right 边界在改变时也发生了变化。</p><p>所以，这里需要搞清楚的两个问题分别是：</p><ol><li>为什么循环条件变成了 left  &lt; right ? （为什么right初始值不是nums.length - 1 ，而是nums.length?</li></ol><p>​[ left,  right ) 由左闭右开的定义可知，这个区间可以取到left，但是永远取不到right。这也是为什么一开始我们要把right &#x3D; nums.length，如果right 仍然从数组的最后一个元素开始取，那么就永远查询不到target就是最后一个元素的情况，因为左闭右开区间，右区间的临界点值是永远取不到的。</p><p>​所以如果区间取不到right，那么当left &#x3D;&#x3D; right 的时候， 这就已经不是一个合法区间了，不必再进入循环。2.</p><ol start="2"><li>为什么当 区间中点值大于target的时候，right正好取到mid？</li></ol><p>​这个问题和问题1的本质是一样的，由于左闭右开区间永远不会取到right，但是却会取到刚好在right左边的这个值，举个例子：</p><p>​<code>[1,2,3,4,5] target = 2</code></p><p>​第一轮循环时，下标为mid的元素为3，那么需要移动right，如果right &#x3D; mid -1，那么下一轮查找的区间就会变成[0, 1)，而其中包含的元素其实是[1,2），但是由于区间左闭右开，2永远不能被区间给取到，我们也就直接漏掉了正确答案。所以，right 只能取mid，因为mid已经被证实了不等于target，所以right 完全可以等于mid。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>由这两种思路对比可知，区间定义的不同将会直接影响到循环条件和右边界的取值，搞清楚不同区间定义和二者之间的关系，就搞清楚了二分查找的基本思路。</p><h2 id="例题一-35-搜索插入位置（左闭右闭）"><a href="#例题一-35-搜索插入位置（左闭右闭）" class="headerlink" title="例题一 35.搜索插入位置（左闭右闭）"></a>例题一 35.搜索插入位置（左闭右闭）</h2><p>下面我们再以两道例题，来深刻体验一下两种区间定义的区别。</p><p><a href="https://leetcode.cn/problems/search-insert-position/">Leetcode 35.搜索插入位置</a></p><p><strong>题目</strong> 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 O(log n) 的算法。</p><p><strong>思路分析</strong> 题目中的几个重点：1、排序数组  2、查找目标值 ，这是典型的二分查找应用的前提。这道题目只不过是在704.二分查找的基础上增加了一个如果不存在目标值如何处理的情况。</p><h3 id="区间选择"><a href="#区间选择" class="headerlink" title="区间选择"></a>区间选择</h3><p>这道题目用两种区间定义都是可以解决的，为了更加深刻地理解左闭右闭区间， 我们暂且先采用这种定义。</p><h3 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">      <span class="comment">// 由于数组是升序无重复元素的数组，所以如果target小于了nums[0],它就需要被排在索引为0的位置</span></span><br><span class="line">        <span class="keyword">if</span>(target &lt; nums[<span class="number">0</span>] || nums.length == <span class="number">0</span> || nums == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//同理 如果target大于了数组中最大的元素，就直接给排到最后，不用进循环了</span></span><br><span class="line">        <span class="keyword">if</span>(target &gt; nums[nums.length - <span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> nums.length;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//左闭右闭</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(target &gt; nums[mid])&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &lt; nums[mid])&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//为什么是left，下面进行详细说明</span></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理完毕target小于第一个元素 以及target大于最后一个元素的简单情况，剩下的就是target的大小在数组大小的范围内的情况了，此时也有两种情况。</p><ol><li>数组中存在target</li></ol><p>​这种情况就是典型的二分查找写法，这里不再赘述。</p><ol start="2"><li>数组中不存在target，所以target需要被插入到数组中间的位置。</li></ol><p>​这种情况，在代码中的体现只有一个 return left ; 那么究竟为什么应该插入的位置是最后left停留的位置呢？</p><p>​这就涉及到左闭右闭区间定义时，循环结束条件的写法了。我们知道，如果数组中不存在target，那么当循环结束时，必然已经是left &gt; right 。举个例子：</p><p>​<code>[1,3,5,7] target = 6</code></p><p>​目标值不存在于数组中，所以循环会经历这样的过程：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一轮循环 初始时</span></span><br><span class="line">left = <span class="number">0</span> </span><br><span class="line">right = <span class="number">3</span>;</span><br><span class="line">mid = <span class="number">1</span>；</span><br><span class="line"><span class="comment">//进行条件判断后</span></span><br><span class="line">left = <span class="number">2</span></span><br><span class="line">right = <span class="number">3</span>;</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">       l  r </span><br><span class="line"></span><br><span class="line"><span class="comment">//第二轮循环 初始时</span></span><br><span class="line">left = <span class="number">2</span></span><br><span class="line">right = <span class="number">3</span></span><br><span class="line">mid = <span class="number">2</span></span><br><span class="line"><span class="comment">//进行条件判断后 5 &lt; 6 移动left</span></span><br><span class="line">left = <span class="number">3</span> right =<span class="number">3</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line">          l&amp;r</span><br><span class="line"></span><br><span class="line">   <span class="comment">//此时 left 和 right 已经相等了，但由于是合法区间，所以再进一次循环</span></span><br><span class="line">         <span class="comment">//此时 mid == 3 但是 7 &gt; 6 所以移动right</span></span><br><span class="line">         </span><br><span class="line"><span class="comment">//所以，当循环结束时，会变成</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line">       r  l </span><br><span class="line">         </span><br><span class="line"><span class="comment">//由此我们也可以得出一个结论，如果将区间定义为左闭右闭，那么找不到值，循环结束后会变成right在左，left在右的情况</span></span><br><span class="line">     <span class="comment">// 此时一定是 nums[right] &lt; target &lt; nums[left] 的情况，由插入规则可以得出，应当返回left</span></span><br><span class="line">         </span><br></pre></td></tr></table></figure><h2 id="例题二-278-第一个错误的版本（左闭右开）"><a href="#例题二-278-第一个错误的版本（左闭右开）" class="headerlink" title="例题二 278. 第一个错误的版本（左闭右开）"></a>例题二 <a href="https://leetcode.cn/problems/first-bad-version/">278. 第一个错误的版本</a>（左闭右开）</h2><p>上面讲解了一种使用左闭右闭区间思路的例题，而第二题则是使用左闭右开区间更加方便快捷的。</p><p><a href="https://leetcode.cn/problems/first-bad-version/">Leetcode 278. 第一个错误的版本</a></p><p><strong>题目</strong> 你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p><p>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。</p><p>你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p><p><strong>思路分析</strong>  由1 - n 之间的正整数，显然是单调递增的，符合二分查找的应用前提。但问题在于，1 - n 之间判定条件只有两种结果，要么是false（版本正确），要么是true（版本错误）。 无法像传统二分法那样一直砍一半直到找到一个mid符合条件，因为可能有无数个mid都符合条件。并且题目中还要求尽量减少调用 isBadVersion（）的次数，所以暴力解法显然会超时。</p><h2 id="代码思路-1"><a href="#代码思路-1" class="headerlink" title="代码思路"></a>代码思路</h2><p>首先我们来看一种暴力解法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> <span class="keyword">extends</span> <span class="title class_">VersionControl</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstBadVersion</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!isBadVersion(mid))&#123;</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               right = mid;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">while</span>(right - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; isBadVersion(right - <span class="number">1</span>) )&#123;</span><br><span class="line">        right--;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> right;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种暴力思路非常好理解，先用二分查找法，找到一个错误的版本，直接将right移动到这里，然后一个一个往前判断，只要前面还是true，right就一直往前走，直到找到第一个错误版本。</p><p>好理解，但缺点是这很有可能会调用很多次isBadVersion。举个例子，假如n为20000000，但实际上错误版本从第2个就开始了，那么第二个while循环将会从right &#x3D; 10000000开始一直往前，调用10000000 -1 次，这显然是非常浪费资源的，事实上，这种暴力解法也会超时无法AC。</p><h3 id="正确思路"><a href="#正确思路" class="headerlink" title="正确思路"></a>正确思路</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> <span class="keyword">extends</span> <span class="title class_">VersionControl</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstBadVersion</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左闭右开区间</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(isBadVersion(mid))&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么说本题更加适合用左闭右开的思路呢？</p><p>​首先，与传统二分查找不同的是，这道题目中有多个版本满足“错误版本”的条件，如果像上面那样采取死循环，一定会超时。所以我们肯定希望，用二分法结束循环的时候，区间里最好只剩下1个值，正好是我们需要寻找的起点。而左闭右开区间的结束条件是可以符合这个情况的，因为当左闭右开区间结束循环时，正好 left &#x3D;&#x3D; right。</p><p>那么我们继续思考，在这里使用二分法，每一次查找的边界应该如何改变呢？依据什么条件呢？</p><p>​由题设可知，如果用isBadVersion（）进行判断的话，版本情况实际上应该是这样的：</p><p>​<code>[false , false ………… , true , true …………true]</code></p><p>所以，很显然， 当mid为false的时候，需要继续移动left，以缩小和正确答案之间的距离；而当mid取值为true的时候，应该移动right，因为mid不一定就是第一个错误的版本，但它之后的版本一定不是第一个错误版本，排除后面的情况。</p><p>举个例子：</p><p><code>[false, false, false , true, true];</code></p><p>此时n &#x3D; 5 , bad &#x3D; 4;</p><p>第一个mid：left + （right - left ）&#x2F; 2 &#x3D; 3  false   left 移动到mid + 1 所以left &#x3D; 4，实际上已经到了正确答案，但由于right还没能被缩小，所以继续进入循环。</p><p>第二个mid：mid &#x3D; 4, 已经为 true，需要移动right &#x3D; mid，此时区间已经缩小为[4 , 4），left &#x3D;&#x3D; right ，此时left或者right都是正确的返回值。</p><p>如果使用左闭右闭区间，最后会变成right &#x3D; 3，left &#x3D; 4，需要额外判定left到达的地方是否为起点的情况，所以显然这里使用左闭右开区间是更优解。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>二分查找法是解决有序数组中查找元素问题的经典解法，其难点就在于区间定义和边界取值，有时候结合两种不同区间的循环结束状态，可以选择更优解。</p>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 92 反转链表 II 双指针解题思路</title>
      <link href="/2023/11/11/Leetcode-92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-II-%E5%8F%8C%E6%8C%87%E9%92%88%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF/"/>
      <url>/2023/11/11/Leetcode-92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-II-%E5%8F%8C%E6%8C%87%E9%92%88%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-92-反转链表-II-双指针解题思路"><a href="#Leetcode-92-反转链表-II-双指针解题思路" class="headerlink" title="Leetcode 92 反转链表 II 双指针解题思路"></a>Leetcode 92 反转链表 II 双指针解题思路</h1><p><a href="https://leetcode.cn/problems/reverse-linked-list-ii/">Leetcode 92 反转链表 II</a></p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p><strong>题目</strong> 给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;&#x3D; right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</p><p>由题设可以得知，left 和 right 是整数，含义为第left个节点和第right个结点。因此我们自然可以想到一个简单的思路：即，将left的前一个节点和right的后一个节点记下，将left和right中间段的子链表反转过后再重新连接完整链表即可。</p><h2 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h2><ul><li>虚拟头节点</li></ul><p>​凡是涉及边界处理的题设，使用虚拟头节点是最简洁的办法，最终我们只需要返回dummyHead.next即可，无需再考虑head本身也需要被反转的特殊情况。</p><p>​<code>ListNode dummyHead = new ListNode(0);</code></p><p>​<code>dummyHead.next = head;</code></p><ul><li>记录left的前一个节点</li></ul><p>​使用变量count计数，双指针pre和cur依次遍历并且直到找到left</p><p>​<code>int count = 1;</code></p><p>​<code>ListNode pre = dummyHead;</code></p><p>​<code>ListNode cur = head;</code></p><p>​<code>while(count != left)&#123; pre = cur; cur = cur.next; count++;&#125;</code></p><p>​直到找到了count &#x3D;&#x3D; left，此时的cur指向的就是第left个节点，而pre就是第left个节点的前一个节点。</p><p>​记录一下：</p><p>​<code>ListNode before = pre;</code></p><p>​<code>ListNode start = cur;</code></p><p>​这样，我们就找到了要被反转的子链表的第一个节点，和它的前一个节点。</p><ul><li>记录right的后一个节点</li></ul><p>​同样的，我们让pre、cur以及count继续往后走，当count &#x3D;&#x3D; right的时候，我们也就找到了需要被反转的子链表的最后一个节点，和它的后一个节点。</p><p>​<code>ListNode end = cur;</code></p><p>​<code>ListNode after = cur.next;</code></p><ul><li>进入反转链表逻辑</li></ul><p>​反转之前，先把子链表的前后都断开。</p><p>​<code>before.next = null;</code></p><p>​<code>end.next = null;</code></p><p>​这里的链表反转逻辑就是单链表反转逻辑，不再详述。</p><p>​<code>reverse(start,end);</code></p><ul><li><p>重新连接新的链表</p><p><code>before.next = end;</code></p><p><code>start.next = after;</code></p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本题重点是用了双指针的思路，并且只遍历了一次链表，把子链表反转逻辑切割成完整的单链表反转，在边界问题处理上使用了虚拟头节点。</p>]]></content>
      
      
      <categories>
          
          <category> 技术相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 61 旋转链表 成环方法解题思路</title>
      <link href="/2023/11/10/Leetcode-61-%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8-%E6%88%90%E7%8E%AF%E6%96%B9%E6%B3%95%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF/"/>
      <url>/2023/11/10/Leetcode-61-%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8-%E6%88%90%E7%8E%AF%E6%96%B9%E6%B3%95%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-61-旋转链表-成环方法解题思路"><a href="#Leetcode-61-旋转链表-成环方法解题思路" class="headerlink" title="Leetcode 61 旋转链表 成环方法解题思路"></a>Leetcode 61 旋转链表 成环方法解题思路</h1><p><a href="https://leetcode.cn/problems/rotate-list/">Leetcode 61 旋转链表</a></p><h2 id="题目-思路分析"><a href="#题目-思路分析" class="headerlink" title="题目&amp;思路分析"></a>题目&amp;思路分析</h2><p><strong>题目</strong> 给你一个链表的头节点 <code>head</code> ，旋转链表，将链表每个节点向右移动 <code>k</code> 个位置。</p><p><strong>分析</strong>  由题目中给出的例子：</p><p>1–&gt;2–&gt;3–&gt;4–&gt;5 输入  k &#x3D; 2 </p><p>输出结果为： [4,5,1,2,3]</p><p>不难看出，k &#x3D; 2 就是原始head往后移动了两个位置，从而尾巴上面的节点被依次“挤”到了前面来。但这里要注意的是，要完成节点位置的变换，而不是简单地修改节点的值。所以，我们可以自然想到，把原始链表变成环，再从头节点开始数到第 链表长度（记为length） - k 个位置时，把下一个节点记为新头节点，并且在此处断开指针，即可获得新的链表。</p><p>至于为什么是找到 length - k 个位置，是因为“每个节点向后移动k个位置”这句话隐含的意思即为，后面k个节点都将移动到链表前面去。因此，从前往后数可以留下的节点数自然就是 length - k 个。</p><h2 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h2><p>从题意分析可以大概理清本题的一个代码思路：</p><ol><li>成环需要找到原链表的尾结点，让它指向头节点</li><li>需要链表的长度（此处还应该考虑length 和 k 之间的关系）</li><li>for循环找到 length - k 个位置，断开链表 重新返回新头节点</li></ol><h3 id="剪枝操作"><a href="#剪枝操作" class="headerlink" title="剪枝操作"></a>剪枝操作</h3><p>考虑到一些简单情况无需进行节点操作返回head即可，所以先来处理这些情况。</p><p><code>if(head = null || head.next == null || k == 0)&#123; return head;&#125;</code></p><p>当head本身为空，或者链表只有1个节点，或者k值为0（即移动0个位置），都是不需要对链表进行操作的，直接返回head即可。</p><h3 id="寻找尾结点和计算链表长度"><a href="#寻找尾结点和计算链表长度" class="headerlink" title="寻找尾结点和计算链表长度"></a>寻找尾结点和计算链表长度</h3><p><code>ListNode last = head;</code></p><p><code>int length = 1;</code></p><p>注，这里length从1开始计算有几个原因：</p><ol><li>last是从head开始，head是链表长度为1的位置，不必从0开始</li><li>接下来的循环结束条件必须是last.next !&#x3D; null，才能保证last最后停留的位置是链表的尾结点位置，如果length从0开始，会比实际长度小1。</li></ol><p>遍历寻找尾结点：</p><p><code>while(last.next != null)&#123;last = last.next; length++;&#125;</code></p><p>这样，我们就得到了原始链表的长度 length。</p><h3 id="处理k值"><a href="#处理k值" class="headerlink" title="处理k值"></a>处理k值</h3><p>我们不难想到，当k值为0 或者 k值为length的倍数时，链表都是无需被操作的。</p><p>而当k值大于了length，也就意味着k会在这个已经成环的链表里面转圈圈，所以，我们进行如下处理：</p><p><code>if(k &gt;= length)&#123;</code></p><p><code>k %= length;</code></p><p><code>//如果k == 0 了，说明k是length的倍数，不需要再进行链表操作了，直接返回</code></p><p><code>if(k == 0)&#123;</code></p><p><code>return head;</code>}&#96;</p><p><code>&#125;</code></p><p>以题设[1,2,3,4,5] k &#x3D; 2 为例， 这个时候 k &#x3D; 7 的效果实际上和k &#x3D; 2 是一致的，所以可以进行预处理。</p><h3 id="链表成环"><a href="#链表成环" class="headerlink" title="链表成环"></a>链表成环</h3><p>这里不难理解，直接写代码：</p><p><code>ListNode temp = head;</code></p><p><code>last.next = temp;</code></p><h3 id="寻找新的尾节点和头节点"><a href="#寻找新的尾节点和头节点" class="headerlink" title="寻找新的尾节点和头节点"></a>寻找新的尾节点和头节点</h3><p><code>ListNode newTail = head;</code></p><p><code>for(int i = 1; i &lt; length - k; i++)&#123;</code></p><p><code>newTail = newTail.next;&#125;</code></p><p>注意两点：</p><ol><li>这里 i 从 1开始的原因和length从1开始的原因一致，因为是从头节点开始找的，所以已经有一个节点了，从1开始计算。</li><li>length - k 是因为k已经进行了上面的预处理，k即使再大，经过求余以后也可以保证小于length，从而这个循环是有意义的。</li></ol><p>找到新的尾结点后，它的下一个节点就是新的头节点。</p><p><code>ListNode newHead = newTail.next;</code></p><p>断开环形链表，返回新头：</p><p><code>newTail.next = null;</code></p><p><code>return newHead;</code></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总体思路就是让链表成环，k在环里转圈圈，找到合适的位置断开。</p><p>注意点就是处理k值和链表长度length的关系，其他部分相对简单。</p>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 344  反转字符串</title>
      <link href="/2023/11/09/Leetcode-344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2023/11/09/Leetcode-344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode344-反转字符串"><a href="#Leetcode344-反转字符串" class="headerlink" title="Leetcode344  反转字符串"></a>Leetcode344  反转字符串</h1><p><a href="https://leetcode.cn/problems/reverse-string/">344. 反转字符串</a></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p><strong>题目：</strong>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>s</code> 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a>修改输入数组**、使用 O(1) 的额外空间解决这一问题。</p><p><strong>分析：</strong>简单题，直接上代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">        <span class="comment">//定义头尾下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> s.length - <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> s[j];</span><br><span class="line">            s[j] = s[i];</span><br><span class="line">            s[i] = temp;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可以看成是一道字符串题，也可以看作是一道简单的双指针题目，i、j的值每交换一次，就朝中点移动一步，直到i、j走到同一个位置</p>]]></content>
      
      
      <categories>
          
          <category> 技术相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
